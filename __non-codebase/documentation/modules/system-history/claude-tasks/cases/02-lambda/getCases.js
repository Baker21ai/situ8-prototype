/**
 * AWS Lambda Function: Get Cases
 * Handles case listing with filtering, pagination, and multi-tenant isolation
 */

const AWS = require('aws-sdk');
const dynamodb = new AWS.DynamoDB.DocumentClient();

// Configuration
const CASES_TABLE = process.env.CASES_TABLE || 'Situ8_Cases';
const TIMELINE_TABLE = process.env.TIMELINE_TABLE || 'Situ8_CaseTimeline';

/**
 * Lambda handler for retrieving cases
 */
exports.handler = async (event) => {
  console.log('Get cases request:', JSON.stringify(event, null, 2));

  try {\n    // Extract company ID from Cognito JWT claims\n    const claims = event.requestContext.authorizer.claims;\n    const companyId = claims['custom:companyId'];\n    const userId = claims.sub;\n\n    if (!companyId || !userId) {\n      return {\n        statusCode: 401,\n        headers: {\n          'Content-Type': 'application/json',\n          'Access-Control-Allow-Origin': '*'\n        },\n        body: JSON.stringify({\n          error: 'Authentication required - missing company or user ID'\n        })\n      };\n    }\n\n    // Parse query parameters\n    const queryParams = event.queryStringParameters || {};\n    const {\n      status,\n      priority,\n      caseType,\n      phase,\n      leadInvestigator,\n      investigator,\n      siteId,\n      createdAfter,\n      createdBefore,\n      searchTerm,\n      caseNumber,\n      overdue,\n      multiSite,\n      requiresApproval,\n      sensitivityLevel,\n      limit = '50',\n      page = '1',\n      sortField = 'createdAt',\n      sortDirection = 'desc',\n      includeTimeline = 'false'\n    } = queryParams;\n\n    const pageSize = Math.min(parseInt(limit), 100); // Max 100 items per page\n    const pageNumber = Math.max(parseInt(page), 1);\n\n    let queryResult;\n    let cases = [];\n\n    // Determine which index to use based on filters\n    if (status) {\n      // Use CompanyStatusIndex for status-based queries\n      queryResult = await dynamodb.query({\n        TableName: CASES_TABLE,\n        IndexName: 'CompanyStatusIndex',\n        KeyConditionExpression: 'companyId = :companyId AND #status = :status',\n        ExpressionAttributeNames: {\n          '#status': 'status'\n        },\n        ExpressionAttributeValues: {\n          ':companyId': companyId,\n          ':status': status\n        },\n        ScanIndexForward: sortDirection === 'asc',\n        Limit: pageSize * 2 // Get extra for filtering\n      }).promise();\n      \n      cases = queryResult.Items;\n    } else if (leadInvestigator) {\n      // Use InvestigatorIndex for investigator-based queries\n      queryResult = await dynamodb.query({\n        TableName: CASES_TABLE,\n        IndexName: 'InvestigatorIndex',\n        KeyConditionExpression: 'leadInvestigatorId = :investigatorId',\n        ExpressionAttributeValues: {\n          ':investigatorId': leadInvestigator,\n          ':companyId': companyId\n        },\n        FilterExpression: 'companyId = :companyId',\n        ScanIndexForward: sortDirection === 'asc',\n        Limit: pageSize * 2\n      }).promise();\n      \n      cases = queryResult.Items;\n    } else if (priority) {\n      // Use PriorityIndex for priority-based queries\n      queryResult = await dynamodb.query({\n        TableName: CASES_TABLE,\n        IndexName: 'PriorityIndex',\n        KeyConditionExpression: 'companyId = :companyId AND priority = :priority',\n        ExpressionAttributeValues: {\n          ':companyId': companyId,\n          ':priority': priority\n        },\n        ScanIndexForward: sortDirection === 'asc',\n        Limit: pageSize * 2\n      }).promise();\n      \n      cases = queryResult.Items;\n    } else {\n      // Use CreatedAtIndex for general queries\n      queryResult = await dynamodb.query({\n        TableName: CASES_TABLE,\n        IndexName: 'CreatedAtIndex',\n        KeyConditionExpression: 'companyId = :companyId',\n        ExpressionAttributeValues: {\n          ':companyId': companyId\n        },\n        ScanIndexForward: sortDirection === 'asc',\n        Limit: pageSize * 2\n      }).promise();\n      \n      cases = queryResult.Items;\n    }\n\n    // Apply additional filters\n    let filteredCases = cases.filter(caseItem => {\n      // Company isolation (already handled by query, but double-check)\n      if (caseItem.companyId !== companyId) return false;\n      \n      // Case type filter\n      if (caseType && caseItem.caseType !== caseType) return false;\n      \n      // Current phase filter\n      if (phase && caseItem.currentPhase !== phase) return false;\n      \n      // Investigator filter (for team member searches)\n      if (investigator && !caseItem.investigators.includes(investigator)) return false;\n      \n      // Site filter\n      if (siteId && caseItem.primarySiteId !== siteId && !caseItem.involvedSites.includes(siteId)) return false;\n      \n      // Date range filters\n      if (createdAfter && new Date(caseItem.createdAt) < new Date(createdAfter)) return false;\n      if (createdBefore && new Date(caseItem.createdAt) > new Date(createdBefore)) return false;\n      \n      // Case number search\n      if (caseNumber && !caseItem.caseNumber.toLowerCase().includes(caseNumber.toLowerCase())) return false;\n      \n      // Text search (title, description)\n      if (searchTerm) {\n        const searchLower = searchTerm.toLowerCase();\n        const titleMatch = caseItem.title.toLowerCase().includes(searchLower);\n        const descMatch = caseItem.description.toLowerCase().includes(searchLower);\n        const tagMatch = caseItem.tags.some(tag => tag.toLowerCase().includes(searchLower));\n        if (!titleMatch && !descMatch && !tagMatch) return false;\n      }\n      \n      // Overdue filter\n      if (overdue === 'true') {\n        const now = new Date();\n        const isOverdue = (caseItem.targetCompletionDate && new Date(caseItem.targetCompletionDate) < now) ||\n                         (caseItem.regulatoryDeadline && new Date(caseItem.regulatoryDeadline) < now);\n        if (!isOverdue) return false;\n      }\n      \n      // Multi-site filter\n      if (multiSite === 'true' && !caseItem.requiresSiteCoordination) return false;\n      \n      // Requires approval filter\n      if (requiresApproval === 'true' && !caseItem.requiresApproval) return false;\n      \n      // Sensitivity level filter\n      if (sensitivityLevel && caseItem.sensitivityLevel !== sensitivityLevel) return false;\n      \n      return true;\n    });\n\n    // Sort if not using database sort\n    if (sortField !== 'createdAt') {\n      filteredCases.sort((a, b) => {\n        const aVal = a[sortField];\n        const bVal = b[sortField];\n        \n        if (aVal < bVal) return sortDirection === 'asc' ? -1 : 1;\n        if (aVal > bVal) return sortDirection === 'asc' ? 1 : -1;\n        return 0;\n      });\n    }\n\n    // Calculate pagination\n    const totalCount = filteredCases.length;\n    const totalPages = Math.ceil(totalCount / pageSize);\n    const startIndex = (pageNumber - 1) * pageSize;\n    const endIndex = Math.min(startIndex + pageSize, totalCount);\n    const paginatedCases = filteredCases.slice(startIndex, endIndex);\n\n    // Include timeline data if requested\n    if (includeTimeline === 'true' && paginatedCases.length > 0) {\n      await Promise.all(paginatedCases.map(async (caseItem) => {\n        try {\n          const timelineResult = await dynamodb.query({\n            TableName: TIMELINE_TABLE,\n            IndexName: 'CaseTimelineIndex',\n            KeyConditionExpression: 'caseId = :caseId',\n            ExpressionAttributeValues: {\n              ':caseId': caseItem.id\n            },\n            ScanIndexForward: false, // Latest first\n            Limit: 10 // Last 10 events\n          }).promise();\n          \n          caseItem.recentTimeline = timelineResult.Items;\n        } catch (error) {\n          console.error(`Error fetching timeline for case ${caseItem.id}:`, error);\n          caseItem.recentTimeline = [];\n        }\n      }));\n    }\n\n    // Calculate statistics\n    const statistics = {\n      totalCases: totalCount,\n      openCases: filteredCases.filter(c => ['draft', 'active', 'pending_review'].includes(c.status)).length,\n      overdueCases: filteredCases.filter(c => {\n        const now = new Date();\n        return (c.targetCompletionDate && new Date(c.targetCompletionDate) < now) ||\n               (c.regulatoryDeadline && new Date(c.regulatoryDeadline) < now);\n      }).length,\n      pendingApproval: filteredCases.filter(c => c.approvalStatus === 'pending').length,\n      \n      // Breakdown by category\n      byStatus: {},\n      byPriority: {},\n      byType: {},\n      byPhase: {}\n    };\n\n    // Count by categories\n    filteredCases.forEach(caseItem => {\n      // By status\n      statistics.byStatus[caseItem.status] = (statistics.byStatus[caseItem.status] || 0) + 1;\n      \n      // By priority\n      statistics.byPriority[caseItem.priority] = (statistics.byPriority[caseItem.priority] || 0) + 1;\n      \n      // By type\n      statistics.byType[caseItem.caseType] = (statistics.byType[caseItem.caseType] || 0) + 1;\n      \n      // By phase\n      statistics.byPhase[caseItem.currentPhase] = (statistics.byPhase[caseItem.currentPhase] || 0) + 1;\n    });\n\n    return {\n      statusCode: 200,\n      headers: {\n        'Content-Type': 'application/json',\n        'Access-Control-Allow-Origin': '*'\n      },\n      body: JSON.stringify({\n        success: true,\n        data: {\n          cases: paginatedCases,\n          pagination: {\n            currentPage: pageNumber,\n            totalPages,\n            totalCount,\n            pageSize,\n            hasNextPage: pageNumber < totalPages,\n            hasPreviousPage: pageNumber > 1\n          },\n          statistics,\n          filters: {\n            status,\n            priority,\n            caseType,\n            phase,\n            leadInvestigator,\n            investigator,\n            siteId,\n            searchTerm,\n            overdue,\n            multiSite\n          }\n        }\n      })\n    };\n\n  } catch (error) {\n    console.error('Error retrieving cases:', error);\n    \n    return {\n      statusCode: 500,\n      headers: {\n        'Content-Type': 'application/json',\n        'Access-Control-Allow-Origin': '*'\n      },\n      body: JSON.stringify({\n        error: 'Internal server error',\n        message: process.env.NODE_ENV === 'development' ? error.message : 'Something went wrong'\n      })\n    };\n  }\n};"