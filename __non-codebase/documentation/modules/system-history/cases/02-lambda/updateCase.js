/**
 * AWS Lambda Function: Update Case
 * Handles case updates with validation, approval workflow, and audit logging
 */

const AWS = require('aws-sdk');
const dynamodb = new AWS.DynamoDB.DocumentClient();

// Configuration
const CASES_TABLE = process.env.CASES_TABLE || 'Situ8_Cases';
const TIMELINE_TABLE = process.env.TIMELINE_TABLE || 'Situ8_CaseTimeline';

/**
 * Lambda handler for updating cases
 */
exports.handler = async (event) => {
  console.log('Update case request:', JSON.stringify(event, null, 2));

  try {
    // Parse request
    const { pathParameters, body, requestContext } = event;
    const { caseId } = pathParameters;
    const updates = JSON.parse(body);

    // Extract company ID from Cognito JWT claims
    const claims = requestContext.authorizer.claims;
    const companyId = claims['custom:companyId'];
    const userId = claims.sub;
    const userEmail = claims.email;

    if (!companyId || !userId) {
      return {
        statusCode: 401,
        headers: {
          'Content-Type': 'application/json',
          'Access-Control-Allow-Origin': '*'
        },
        body: JSON.stringify({
          error: 'Authentication required - missing company or user ID'
        })
      };
    }

    if (!caseId) {
      return {
        statusCode: 400,
        headers: {
          'Content-Type': 'application/json',
          'Access-Control-Allow-Origin': '*'
        },
        body: JSON.stringify({
          error: 'Case ID is required'
        })
      };
    }

    // Get existing case
    const existingResult = await dynamodb.get({
      TableName: CASES_TABLE,
      Key: { id: caseId, companyId }
    }).promise();

    if (!existingResult.Item) {\n      return {\n        statusCode: 404,\n        headers: {\n          'Content-Type': 'application/json',\n          'Access-Control-Allow-Origin': '*'\n        },\n        body: JSON.stringify({\n          error: 'Case not found'\n        })\n      };\n    }\n\n    const existingCase = existingResult.Item;\n\n    // Verify user has permission to update\n    const hasPermission = await verifyUpdatePermission(existingCase, userId, updates);\n    if (!hasPermission.allowed) {\n      return {\n        statusCode: 403,\n        headers: {\n          'Content-Type': 'application/json',\n          'Access-Control-Allow-Origin': '*'\n        },\n        body: JSON.stringify({\n          error: hasPermission.reason\n        })\n      };\n    }\n\n    // Validate updates\n    const validation = validateUpdates(updates, existingCase);\n    if (!validation.isValid) {\n      return {\n        statusCode: 400,\n        headers: {\n          'Content-Type': 'application/json',\n          'Access-Control-Allow-Origin': '*'\n        },\n        body: JSON.stringify({\n          error: 'Validation failed',\n          details: validation.errors\n        })\n      };\n    }\n\n    // Check for status transitions that require approval\n    const statusChange = updates.status && updates.status !== existingCase.status;\n    const requiresApproval = statusChange && checkStatusTransitionApproval(existingCase.status, updates.status);\n\n    if (requiresApproval && !hasPermission.canApprove) {\n      return {\n        statusCode: 403,\n        headers: {\n          'Content-Type': 'application/json',\n          'Access-Control-Allow-Origin': '*'\n        },\n        body: JSON.stringify({\n          error: 'Status change requires approval from supervisor or admin'\n        })\n      };\n    }\n\n    // Prepare update expression\n    const timestamp = new Date().toISOString();\n    const updateExpression = [];\n    const expressionAttributeNames = {};\n    const expressionAttributeValues = {};\n\n    // Handle different types of updates\n    const allowedUpdates = [\n      'title', 'description', 'status', 'priority', 'currentPhase',\n      'leadInvestigatorId', 'investigators', 'reviewers',\n      'involvedSites', 'requiresSiteCoordination',\n      'initialFindings', 'investigationPlan', 'evidenceSummary',\n      'targetCompletionDate', 'regulatoryDeadline',\n      'sensitivityLevel', 'caseCategory', 'tags',\n      'recommendations', 'estimatedHours', 'actualHours',\n      'costEstimate', 'actualCost', 'confidentialityLevel'\n    ];\n\n    // Build update expression\n    Object.keys(updates).forEach(key => {\n      if (allowedUpdates.includes(key) && updates[key] !== undefined) {\n        const attrName = `#${key}`;\n        const attrValue = `:${key}`;\n        \n        updateExpression.push(`${attrName} = ${attrValue}`);\n        expressionAttributeNames[attrName] = key;\n        expressionAttributeValues[attrValue] = updates[key];\n      }\n    });\n\n    // Always update timestamp and updatedBy\n    updateExpression.push('#updatedAt = :updatedAt', '#updatedBy = :updatedBy');\n    expressionAttributeNames['#updatedAt'] = 'updatedAt';\n    expressionAttributeNames['#updatedBy'] = 'updatedBy';\n    expressionAttributeValues[':updatedAt'] = timestamp;\n    expressionAttributeValues[':updatedBy'] = userId;\n\n    // Handle phase completion\n    if (updates.currentPhase && updates.currentPhase !== existingCase.currentPhase) {\n      const updatedPhasesCompleted = [...(existingCase.phasesCompleted || [])];\n      if (!updatedPhasesCompleted.includes(existingCase.currentPhase)) {\n        updatedPhasesCompleted.push(existingCase.currentPhase);\n      }\n      \n      updateExpression.push('#phasesCompleted = :phasesCompleted');\n      expressionAttributeNames['#phasesCompleted'] = 'phasesCompleted';\n      expressionAttributeValues[':phasesCompleted'] = updatedPhasesCompleted;\n    }\n\n    // Handle case closure\n    if (updates.status === 'closed' && existingCase.status !== 'closed') {\n      updateExpression.push('#closedAt = :closedAt', '#closedBy = :closedBy');\n      expressionAttributeNames['#closedAt'] = 'closedAt';\n      expressionAttributeNames['#closedBy'] = 'closedBy';\n      expressionAttributeValues[':closedAt'] = timestamp;\n      expressionAttributeValues[':closedBy'] = userId;\n      \n      if (updates.closureReason) {\n        updateExpression.push('#closureReason = :closureReason');\n        expressionAttributeNames['#closureReason'] = 'closureReason';\n        expressionAttributeValues[':closureReason'] = updates.closureReason;\n      }\n      \n      if (updates.closureSummary) {\n        updateExpression.push('#closureSummary = :closureSummary');\n        expressionAttributeNames['#closureSummary'] = 'closureSummary';\n        expressionAttributeValues[':closureSummary'] = updates.closureSummary;\n      }\n    }\n\n    // Update case in DynamoDB\n    const updateResult = await dynamodb.update({\n      TableName: CASES_TABLE,\n      Key: { id: caseId, companyId },\n      UpdateExpression: `SET ${updateExpression.join(', ')}`,\n      ExpressionAttributeNames: expressionAttributeNames,\n      ExpressionAttributeValues: expressionAttributeValues,\n      ReturnValues: 'ALL_NEW'\n    }).promise();\n\n    const updatedCase = updateResult.Attributes;\n\n    // Create timeline entry for significant updates\n    const significantUpdates = ['status', 'currentPhase', 'priority', 'leadInvestigatorId'];\n    const hasSignificantUpdate = Object.keys(updates).some(key => significantUpdates.includes(key));\n\n    if (hasSignificantUpdate) {\n      const timelineEntry = {\n        id: `timeline_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        companyId,\n        caseId,\n        timestamp,\n        eventType: 'case_updated',\n        phase: updatedCase.currentPhase,\n        title: generateUpdateTitle(updates, existingCase),\n        description: generateUpdateDescription(updates, existingCase, userEmail),\n        userId,\n        userEmail,\n        metadata: {\n          updatedFields: Object.keys(updates),\n          previousValues: Object.keys(updates).reduce((prev, key) => {\n            prev[key] = existingCase[key];\n            return prev;\n          }, {}),\n          newValues: updates\n        }\n      };\n\n      await dynamodb.put({\n        TableName: TIMELINE_TABLE,\n        Item: timelineEntry\n      }).promise();\n\n      updatedCase.latestTimelineEntry = timelineEntry;\n    }\n\n    console.log(`âœ… Case updated successfully: ${caseId}`);\n\n    return {\n      statusCode: 200,\n      headers: {\n        'Content-Type': 'application/json',\n        'Access-Control-Allow-Origin': '*'\n      },\n      body: JSON.stringify({\n        success: true,\n        data: {\n          case: updatedCase\n        },\n        message: 'Case updated successfully'\n      })\n    };\n\n  } catch (error) {\n    console.error('Error updating case:', error);\n    \n    return {\n      statusCode: 500,\n      headers: {\n        'Content-Type': 'application/json',\n        'Access-Control-Allow-Origin': '*'\n      },\n      body: JSON.stringify({\n        error: 'Internal server error',\n        message: process.env.NODE_ENV === 'development' ? error.message : 'Something went wrong'\n      })\n    };\n  }\n};\n\n/**\n * Verify user has permission to update the case\n */\nasync function verifyUpdatePermission(caseData, userId, updates) {\n  try {\n    // Case creator can always update (unless closed)\n    if (caseData.createdBy === userId && caseData.status !== 'closed') {\n      return { allowed: true, canApprove: false };\n    }\n\n    // Lead investigator can update most fields\n    if (caseData.leadInvestigatorId === userId) {\n      return { allowed: true, canApprove: false };\n    }\n\n    // Team investigators can update some fields\n    if (caseData.investigators && caseData.investigators.includes(userId)) {\n      const restrictedFields = ['status', 'priority', 'leadInvestigatorId', 'sensitivityLevel'];\n      const hasRestrictedUpdate = Object.keys(updates).some(key => restrictedFields.includes(key));\n      \n      if (hasRestrictedUpdate) {\n        return { allowed: false, reason: 'Insufficient permissions to update restricted fields' };\n      }\n      \n      return { allowed: true, canApprove: false };\n    }\n\n    // Reviewers can approve and make status changes\n    if (caseData.reviewers && caseData.reviewers.includes(userId)) {\n      return { allowed: true, canApprove: true };\n    }\n\n    // TODO: Add role-based permissions (supervisor, admin)\n    // For now, deny access\n    return { allowed: false, reason: 'Access denied - not authorized to update this case' };\n\n  } catch (error) {\n    console.error('Error verifying update permission:', error);\n    return { allowed: false, reason: 'Permission check failed' };\n  }\n}\n\n/**\n * Validate case updates\n */\nfunction validateUpdates(updates, existingCase) {\n  const errors = [];\n  \n  // Title validation\n  if (updates.title !== undefined) {\n    if (!updates.title || updates.title.trim().length === 0) {\n      errors.push({ field: 'title', message: 'Title cannot be empty' });\n    } else if (updates.title.length > 200) {\n      errors.push({ field: 'title', message: 'Title must be 200 characters or less' });\n    }\n  }\n  \n  // Description validation\n  if (updates.description !== undefined) {\n    if (!updates.description || updates.description.trim().length === 0) {\n      errors.push({ field: 'description', message: 'Description cannot be empty' });\n    } else if (updates.description.length > 2000) {\n      errors.push({ field: 'description', message: 'Description must be 2000 characters or less' });\n    }\n  }\n  \n  // Status validation\n  if (updates.status !== undefined) {\n    const validStatuses = ['draft', 'active', 'pending_review', 'on_hold', 'escalated', 'completed', 'closed', 'archived'];\n    if (!validStatuses.includes(updates.status)) {\n      errors.push({ field: 'status', message: 'Invalid status' });\n    }\n    \n    // Check valid status transitions\n    const invalidTransitions = {\n      'closed': ['draft', 'active'], // Can't reopen closed cases easily\n      'archived': ['draft', 'active', 'pending_review'] // Archived cases need special handling\n    };\n    \n    if (invalidTransitions[existingCase.status] && invalidTransitions[existingCase.status].includes(updates.status)) {\n      errors.push({ field: 'status', message: `Cannot change status from ${existingCase.status} to ${updates.status}` });\n    }\n  }\n  \n  // Priority validation\n  if (updates.priority !== undefined) {\n    const validPriorities = ['low', 'medium', 'high', 'critical'];\n    if (!validPriorities.includes(updates.priority)) {\n      errors.push({ field: 'priority', message: 'Invalid priority level' });\n    }\n  }\n  \n  // Phase validation\n  if (updates.currentPhase !== undefined) {\n    const validPhases = ['initiation', 'evidence_collection', 'analysis', 'interviews', 'verification', 'reporting', 'review', 'closure'];\n    if (!validPhases.includes(updates.currentPhase)) {\n      errors.push({ field: 'currentPhase', message: 'Invalid investigation phase' });\n    }\n  }\n  \n  // Date validation\n  if (updates.targetCompletionDate !== undefined && updates.targetCompletionDate) {\n    const targetDate = new Date(updates.targetCompletionDate);\n    if (isNaN(targetDate.getTime())) {\n      errors.push({ field: 'targetCompletionDate', message: 'Invalid target completion date' });\n    }\n  }\n  \n  if (updates.regulatoryDeadline !== undefined && updates.regulatoryDeadline) {\n    const regDate = new Date(updates.regulatoryDeadline);\n    if (isNaN(regDate.getTime())) {\n      errors.push({ field: 'regulatoryDeadline', message: 'Invalid regulatory deadline' });\n    }\n  }\n  \n  return {\n    isValid: errors.length === 0,\n    errors\n  };\n}\n\n/**\n * Check if status transition requires approval\n */\nfunction checkStatusTransitionApproval(fromStatus, toStatus) {\n  const requiresApprovalTransitions = {\n    'draft': ['active', 'closed'],\n    'active': ['completed', 'closed'],\n    'pending_review': ['active', 'completed', 'closed'],\n    'on_hold': ['active', 'closed'],\n    'escalated': ['active', 'completed', 'closed'],\n    'completed': ['closed', 'active'] // Reopening\n  };\n  \n  return requiresApprovalTransitions[fromStatus] && requiresApprovalTransitions[fromStatus].includes(toStatus);\n}\n\n/**\n * Generate update title for timeline\n */\nfunction generateUpdateTitle(updates, existingCase) {\n  if (updates.status && updates.status !== existingCase.status) {\n    return `Status changed to ${updates.status.replace('_', ' ')}`;\n  }\n  \n  if (updates.currentPhase && updates.currentPhase !== existingCase.currentPhase) {\n    return `Phase changed to ${updates.currentPhase.replace('_', ' ')}`;\n  }\n  \n  if (updates.priority && updates.priority !== existingCase.priority) {\n    return `Priority changed to ${updates.priority}`;\n  }\n  \n  if (updates.leadInvestigatorId && updates.leadInvestigatorId !== existingCase.leadInvestigatorId) {\n    return 'Lead investigator reassigned';\n  }\n  \n  return 'Case updated';\n}\n\n/**\n * Generate update description for timeline\n */\nfunction generateUpdateDescription(updates, existingCase, userEmail) {\n  const changes = [];\n  \n  Object.keys(updates).forEach(key => {\n    if (updates[key] !== existingCase[key]) {\n      changes.push(`${key}: ${existingCase[key]} â†’ ${updates[key]}`);\n    }\n  });\n  \n  return `Case updated by ${userEmail}. Changes: ${changes.join(', ')}`;\n}"